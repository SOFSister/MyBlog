<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java面试题（汇总） | feedsheep</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="feedsheep's boring life">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.8afab5e2.css" as="style"><link rel="preload" href="/assets/js/app.810a8d16.js" as="script"><link rel="preload" href="/assets/js/3.442212e7.js" as="script"><link rel="preload" href="/assets/js/1.960485ad.js" as="script"><link rel="preload" href="/assets/js/13.e03968ea.js" as="script"><link rel="prefetch" href="/assets/js/10.6211b36e.js"><link rel="prefetch" href="/assets/js/11.c00860a9.js"><link rel="prefetch" href="/assets/js/12.6e12ebfa.js"><link rel="prefetch" href="/assets/js/14.592f9782.js"><link rel="prefetch" href="/assets/js/15.36dd357a.js"><link rel="prefetch" href="/assets/js/16.7837cde4.js"><link rel="prefetch" href="/assets/js/17.49bc7553.js"><link rel="prefetch" href="/assets/js/4.dc974ea7.js"><link rel="prefetch" href="/assets/js/5.1d8e4b3a.js"><link rel="prefetch" href="/assets/js/6.4a6a8a8f.js"><link rel="prefetch" href="/assets/js/7.5f56cb2b.js"><link rel="prefetch" href="/assets/js/8.d9114768.js"><link rel="prefetch" href="/assets/js/9.1607f35d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8afab5e2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-999d3bb4><div data-v-999d3bb4><div id="loader-wrapper" class="loading-wrapper" data-v-2c578df8 data-v-999d3bb4 data-v-999d3bb4><div class="loader-main" data-v-2c578df8><div data-v-2c578df8></div><div data-v-2c578df8></div><div data-v-2c578df8></div><div data-v-2c578df8></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-067bd032 data-v-999d3bb4 data-v-999d3bb4><h3 class="title" data-v-067bd032 data-v-067bd032>feedsheep</h3> <p class="description" data-v-067bd032 data-v-067bd032>feedsheep's boring life</p> <label id="box" class="inputBox" data-v-067bd032 data-v-067bd032><input type="password" value="" data-v-067bd032> <span data-v-067bd032>Konck! Knock!</span> <button data-v-067bd032>OK</button></label> <div class="footer" data-v-067bd032 data-v-067bd032><span data-v-067bd032><i class="iconfont reco-theme" data-v-067bd032></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-067bd032>vuePress-theme-reco</a></span> <span data-v-067bd032><i class="iconfont reco-copyright" data-v-067bd032></i> <a data-v-067bd032><span data-v-067bd032>feedsheep</span>
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-999d3bb4><header class="navbar" data-v-999d3bb4><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="feedsheep" class="logo"> <span class="site-name">feedsheep</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Git/" class="nav-link"><i class="undefined"></i>
  Git
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/SSM/" class="nav-link"><i class="undefined"></i>
  SSM
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-suggestion"></i>
      学习
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/Java/" class="nav-link router-link-active"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/docs/SSM/" class="nav-link"><i class="undefined"></i>
  SSM
</a></li><li class="dropdown-item"><!----> <a href="/docs/Git/" class="nav-link"><i class="undefined"></i>
  Git
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      生活
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/PhotoAlbum/" class="nav-link"><i class="undefined"></i>
  相册
</a></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  归档
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      其他
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/SOFSister" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-999d3bb4></div> <aside class="sidebar" data-v-999d3bb4><div class="personal-info-wrapper" data-v-e2878dae data-v-999d3bb4><img src="/avatar.jpg" alt="author-avatar" class="personal-img" data-v-e2878dae> <h3 class="name" data-v-e2878dae>
    feedsheep
  </h3> <div class="num" data-v-e2878dae><div data-v-e2878dae><h3 data-v-e2878dae>7</h3> <h6 data-v-e2878dae>文章</h6></div> <div data-v-e2878dae><h3 data-v-e2878dae>8</h3> <h6 data-v-e2878dae>标签</h6></div></div> <ul class="social-links" data-v-e2878dae></ul> <hr data-v-e2878dae></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Git/" class="nav-link"><i class="undefined"></i>
  Git
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/SSM/" class="nav-link"><i class="undefined"></i>
  SSM
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-suggestion"></i>
      学习
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/Java/" class="nav-link router-link-active"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/docs/SSM/" class="nav-link"><i class="undefined"></i>
  SSM
</a></li><li class="dropdown-item"><!----> <a href="/docs/Git/" class="nav-link"><i class="undefined"></i>
  Git
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      生活
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/PhotoAlbum/" class="nav-link"><i class="undefined"></i>
  相册
</a></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  归档
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      其他
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/SOFSister" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><a href="/docs/Java/" aria-current="page" class="sidebar-link">Java专区</a></li><li><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html" aria-current="page" class="active sidebar-link">Java面试题（汇总）</a></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-067bd032 data-v-999d3bb4><h3 class="title" data-v-067bd032 data-v-067bd032>Java面试题（汇总）</h3> <!----> <label id="box" class="inputBox" data-v-067bd032 data-v-067bd032><input type="password" value="" data-v-067bd032> <span data-v-067bd032>Konck! Knock!</span> <button data-v-067bd032>OK</button></label> <div class="footer" data-v-067bd032 data-v-067bd032><span data-v-067bd032><i class="iconfont reco-theme" data-v-067bd032></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-067bd032>vuePress-theme-reco</a></span> <span data-v-067bd032><i class="iconfont reco-copyright" data-v-067bd032></i> <a data-v-067bd032><span data-v-067bd032>feedsheep</span>
            
          <!---->
          2022
        </a></span></div></div> <div data-v-999d3bb4><main class="page"><section><div class="page-title"><h1 class="title">Java面试题（汇总）</h1> <div data-v-10e19382><i class="iconfont reco-account" data-v-10e19382><span data-v-10e19382>feedsheep</span></i> <i class="iconfont reco-date" data-v-10e19382><span data-v-10e19382>2022/5/5</span></i> <!----> <i class="tags iconfont reco-tag" data-v-10e19382><span class="tag-item" data-v-10e19382>Java</span><span class="tag-item" data-v-10e19382>面试题</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="_1-面向对象和面向过程的区别"><a href="#_1-面向对象和面向过程的区别" class="header-anchor">#</a> 1.面向对象和面向过程的区别</h2> <ul><li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li> <li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li></ul> <blockquote><p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p> <p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p></blockquote> <h2 id="_2-java语言的特点"><a href="#_2-java语言的特点" class="header-anchor">#</a> 2.Java语言的特点</h2> <ol><li>简单易学；</li> <li>面向对象（封装，继承，多态）；</li> <li>平台无关性（ Java 虚拟机实现平台无关性）；</li> <li>可靠性；</li> <li>安全性；</li> <li>支持多线程（ C++ 11前没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li> <li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li> <li>编译与解释并存；</li></ol> <h2 id="_3-关于jvm-jdk-和-jre最详细通俗的解答"><a href="#_3-关于jvm-jdk-和-jre最详细通俗的解答" class="header-anchor">#</a> 3.关于JVM JDK 和 JRE最详细通俗的解答</h2> <h3 id="_3-1-jvm"><a href="#_3-1-jvm" class="header-anchor">#</a> 3.1.JVM</h3> <p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p> <p><strong>什么是字节码?采用字节码的好处是什么?</strong></p> <blockquote><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote> <p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p> <p><img src="/JavaBasisQuestions.assets/image-20220222083701210.png" alt="image-20220222083701210"></p> <p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p> <blockquote><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote> <p><strong>总结：</strong></p> <p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p> <h3 id="_3-2-jdk和jre"><a href="#_3-2-jdk和jre" class="header-anchor">#</a> 3.2.JDK和JRE</h3> <p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK（Software Development Kit）。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p> <p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p> <p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p> <h2 id="_4-oracle-jdk-和-openjdk-的对比"><a href="#_4-oracle-jdk-和-openjdk-的对比" class="header-anchor">#</a> 4.Oracle JDK 和 OpenJDK 的对比</h2> <p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p> <blockquote><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p> <p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p></blockquote> <p><strong>总结：</strong></p> <ol><li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li> <li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li> <li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li> <li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li> <li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ol> <h2 id="_5-java和c-的区别"><a href="#_5-java和c-的区别" class="header-anchor">#</a> 5.Java和C++的区别</h2> <ul><li>都是面向对象的语言，都支持封装、继承和多态</li> <li>Java 不提供指针来直接访问内存，程序内存更加安全</li> <li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li> <li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li> <li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong></li></ul> <blockquote><p><strong>java中无需结束符的原因</strong></p> <p>Java里面的一切都是对象，是对象的话，字符串肯定就有长度，既然有长度，编译器就可以确定要输出的字符个数，当然也就没有必要去浪费那1字节的空间用以标明字符串的结束了。比如，数组对象里有一个属性length，就是数组的长度，String类里面有方法length()可以确定字符串的长度，因此对于输出函数来说，有直接的大小可以判断字符串的边界，编译器就没必要再去浪费一个空间标识字符串的结束</p></blockquote> <h2 id="_6-字符型常量和字符串常量的区别"><a href="#_6-字符型常量和字符串常量的区别" class="header-anchor">#</a> 6.字符型常量和字符串常量的区别</h2> <ol><li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li> <li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li> <li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li></ol> <blockquote><p><img src="/JavaBasisQuestions.assets/image-20220222091545605.png" alt="image-20220222091545605"></p></blockquote> <h2 id="_7-构造器constructor是否可被override"><a href="#_7-构造器constructor是否可被override" class="header-anchor">#</a> 7.构造器Constructor是否可被override</h2> <p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p> <h2 id="_8-重载和重写的区别"><a href="#_8-重载和重写的区别" class="header-anchor">#</a> 8.重载和重写的区别</h2> <blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p> <p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote> <h3 id="_8-1重载"><a href="#_8-1重载" class="header-anchor">#</a> 8.1重载：</h3> <p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p> <p><img src="/JavaBasisQuestions.assets/image-20220222092408113.png" alt="image-20220222092408113"></p> <p>**综上：**重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p> <h3 id="_8-2重写"><a href="#_8-2重写" class="header-anchor">#</a> 8.2重写</h3> <p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p> <ol><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li> <li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li> <li>构造方法无法被重写</li></ol> <p>⭐️ 关于 <strong>重写的返回值类</strong>型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p> <p>**综上：**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p> <h3 id="_8-3总结"><a href="#_8-3总结" class="header-anchor">#</a> 8.3总结</h3> <p><img src="/JavaBasisQuestions.assets/image-20220222093544073.png" alt="image-20220222093544073"></p> <blockquote><p><strong>方法的重写要遵循“两同两小一大”</strong></p> <ul><li>“两同”即方法名相同、形参列表相同；</li> <li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li> <li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;超级英雄&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperMan</span> <span class="token keyword">extends</span> <span class="token class-name">Hero</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;超人&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Hero</span> <span class="token function">hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperSuperMan</span> <span class="token keyword">extends</span> <span class="token class-name">SuperMan</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;超级超级英雄&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">SuperMan</span> <span class="token function">hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SuperMan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h2 id="_9-java面向对象编程三大特性-封装-继承-多态"><a href="#_9-java面向对象编程三大特性-封装-继承-多态" class="header-anchor">#</a> 9.Java面向对象编程三大特性：封装 继承 多态</h2> <h3 id="_9-1封装"><a href="#_9-1封装" class="header-anchor">#</a> 9.1封装</h3> <p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p> <h3 id="_9-2继承"><a href="#_9-2继承" class="header-anchor">#</a> 9.2继承</h3> <p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p> <p><strong>关于继承如下 3 点请记住：</strong></p> <ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li> <li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li> <li>子类可以用自己的方式实现父类的方法。</li></ol> <h3 id="_9-3多态"><a href="#_9-3多态" class="header-anchor">#</a> 9.3多态</h3> <p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p> <p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p> <h2 id="_10-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的"><a href="#_10-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的" class="header-anchor">#</a> 10.String StringBuffer 和 StringBuilder 的区别是什么？ String 为什么是不可变的？</h2> <p><strong>可变性</strong></p> <p>简单的来说：<code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p> <blockquote><p>补充：在 Java 9 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p></blockquote> <p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p> <p><strong>线程安全性</strong></p> <p><code>String</code> 中的对象是不可变的，也就可以理解为常量，<strong>线程安全</strong>。</p> <p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。</p> <p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。</p> <p><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p> <p><strong>性能</strong></p> <p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p> <p><strong>对于三者使用的总结：</strong></p> <ol><li>操作少量的数据: 适用 <code>String</code></li> <li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li> <li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol> <h2 id="_11-自动装箱与拆箱"><a href="#_11-自动装箱与拆箱" class="header-anchor">#</a> 11.自动装箱与拆箱</h2> <ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li> <li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul> <h2 id="_12-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#_12-在一个静态方法内调用一个非静态成员为什么是非法的" class="header-anchor">#</a> 12.在一个静态方法内调用一个非静态成员为什么是非法的？</h2> <p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p> <h2 id="_13-在java中定义一个不做事且没有参数的构造方法的作用"><a href="#_13-在java中定义一个不做事且没有参数的构造方法的作用" class="header-anchor">#</a> 13.在java中定义一个不做事且没有参数的构造方法的作用</h2> <p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p> <h2 id="_14-接口和抽象类的区别是什么"><a href="#_14-接口和抽象类的区别是什么" class="header-anchor">#</a> 14.接口和抽象类的区别是什么？</h2> <ol><li>接口的方法默认是 <code>public</code>，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li> <li>接口中除了 <code>static</code>、<code>final</code> 变量，不能有其他变量，而抽象类中则不一定。</li> <li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 <code>extends</code> 关键字扩展多个接口。</li> <li>接口方法默认修饰符是 <code>public</code>，抽象方法可以有 <code>public</code>、<code>protected</code> 和 <code>default</code> 这些修饰符（抽象方法就是为了被重写所以不能使用 <code>private</code> 关键字修饰！）。</li> <li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol> <blockquote><p>备注：</p> <ol><li>在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</li> <li>jdk9 的接口被允许定义私有方法 。</li></ol></blockquote> <p>总结一下 jdk7~jdk9 Java 中接口概念的变化：</p> <ol><li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li> <li>jdk 8 的时候接口可以有默认方法和静态方法功能。</li> <li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li></ol> <h2 id="_15-成员变量与局部变量的区别有哪些"><a href="#_15-成员变量与局部变量的区别有哪些" class="header-anchor">#</a> 15.成员变量与局部变量的区别有哪些？</h2> <ol><li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li> <li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。</li> <li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li> <li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol> <h2 id="_16-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#_16-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="header-anchor">#</a> 16.创建一个对象用什么运算符？对象实体与对象引用有何不同？</h2> <p>new 运算符。</p> <p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p> <p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;</p> <p>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p> <h2 id="_17-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#_17-什么是方法的返回值-返回值在类的方法里的作用是什么" class="header-anchor">#</a> 17.什么是方法的返回值？返回值在类的方法里的作用是什么？</h2> <p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p> <h2 id="_18-一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么"><a href="#_18-一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么" class="header-anchor">#</a> 18.一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</h2> <p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法</p> <h2 id="_19-构造方法有哪些特性"><a href="#_19-构造方法有哪些特性" class="header-anchor">#</a> 19.构造方法有哪些特性？</h2> <ol><li>名字与类名相同。</li> <li>没有返回值，但不能用 void 声明构造函数。</li> <li>生成类的对象时自动执行，无需调用。</li></ol> <h2 id="_20-静态方法和实例方法有何不同"><a href="#_20-静态方法和实例方法有何不同" class="header-anchor">#</a> 20. 静态方法和实例方法有何不同</h2> <ol><li>在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li> <li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li></ol> <h2 id="_21-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#_21-对象的相等与指向他们的引用相等-两者有什么不同" class="header-anchor">#</a> 21.对象的相等与指向他们的引用相等，两者有什么不同？</h2> <p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p> <h2 id="_22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#_22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="header-anchor">#</a> 22.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h2> <p>帮助子类做初始化工作。</p> <h2 id="_23-与-equals-重要"><a href="#_23-与-equals-重要" class="header-anchor">#</a> 23.== 与 equals（重要）</h2> <p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型 == 比较的是值，引用数据类型==比较的是内存地址)。</p> <p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p> <ul><li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li> <li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul> <p><strong>举个例子</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> test1 <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a 为一个引用</span>
        <span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b为另一个引用,对象的内容一样</span>
        <span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 放在常量池中</span>
        <span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 从常量池中查找</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>aa <span class="token operator">==</span> bb<span class="token punctuation">)</span> <span class="token comment">// true</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;aa==bb&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token comment">// false，非同一对象</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;a==b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;aEQb&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">==</span> <span class="token number">42.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// true</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>说明：</strong></p> <ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li> <li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul> <h2 id="_24-hashcode-与-equals-重要"><a href="#_24-hashcode-与-equals-重要" class="header-anchor">#</a> 24. hashCode 与 equals（重要）</h2> <p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p> <p><strong>1)hashCode()介绍:</strong></p> <p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p> <p><strong>2)为什么要有 hashCode？</strong></p> <p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p> <p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p> <p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p> <p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p> <blockquote><p><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote> <p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p> <p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p> <p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p> <h2 id="_25-为什么java中只有值传递"><a href="#_25-为什么java中只有值传递" class="header-anchor">#</a> 25.为什么Java中只有值传递？</h2> <p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p> <p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p> <p><strong>下面通过 3 个例子来给大家说明</strong></p> <blockquote><p><strong>example 1</strong></p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

    <span class="token function">swap</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;num1 = &quot;</span> <span class="token operator">+</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;num2 = &quot;</span> <span class="token operator">+</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
    b <span class="token operator">=</span> temp<span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;a = &quot;</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;b = &quot;</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>结果：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>a = 20
b = 10
num1 = 10
num2 = 20
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="/JavaBasisQuestions.assets/image-20220222135034038.png" alt="image-20220222135034038"></p> <p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p> <p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p> <blockquote><p><strong>example 2</strong></p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">change</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将数组的第一个元素变为0</span>
        array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>结果：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1
0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>解析：</strong></p> <p><img src="/JavaBasisQuestions.assets/image-20220222135404682.png" alt="image-20220222135404682"></p> <p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p> <p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p> <p><strong>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p> <blockquote><p><strong>example 3</strong></p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token class-name">Student</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小张&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Student</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小李&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;s1:&quot;</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;s2:&quot;</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">Student</span> x<span class="token punctuation">,</span> <span class="token class-name">Student</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Student</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span>
        x <span class="token operator">=</span> y<span class="token punctuation">;</span>
        y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;x:&quot;</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;y:&quot;</span> <span class="token operator">+</span> y<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><strong>结果：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>x:小李
y:小张
s1:小张
s2:小李
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>交换之前：</p> <p><img src="/JavaBasisQuestions.assets/image-20220222140107753.png" alt="image-20220222140107753"></p> <p>交换之后：</p> <p><img src="/JavaBasisQuestions.assets/image-20220222140132426.png" alt="image-20220222140132426"></p> <p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p> <blockquote><p>总结</p></blockquote> <p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p> <p>下面再总结一下 Java 中方法参数的使用情况：</p> <ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li> <li>一个方法可以改变一个对象参数的状态。</li> <li>一个方法不能让对象参数引用一个新的对象。</li></ul> <h2 id="_26-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#_26-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="header-anchor">#</a> 26.简述线程、程序、进程的基本概念。以及他们之间关系是什么？</h2> <p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p> <p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p> <p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p> <h2 id="_27-线程有哪些基本状态"><a href="#_27-线程有哪些基本状态" class="header-anchor">#</a> 27.线程有哪些基本状态？</h2> <p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态</p> <p><img src="/JavaBasisQuestions.assets/image-20220223092624457.png" alt="image-20220223092624457"></p> <p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示：</p> <p><img src="/JavaBasisQuestions.assets/image-20220223114320443.png" alt="image-20220223114320443"></p> <p>由上图可以看出：</p> <p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p> <blockquote><p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote> <p>当线程执行 <code>wait()</code>方法之后，线程进入 **WAITING（等待）**状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p> <h2 id="_28-关于-final-关键字的一些总结"><a href="#_28-关于-final-关键字的一些总结" class="header-anchor">#</a> 28.关于 final 关键字的一些总结</h2> <p>final 关键字主要用在三个地方：变量、方法、类。</p> <ol><li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li> <li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li> <li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li></ol> <h2 id="_29-关于java-lang-class类的理解"><a href="#_29-关于java-lang-class类的理解" class="header-anchor">#</a> 29.关于java.lang.Class类的理解</h2> <ol><li><p>类的加载过程</p> <p>程序经过javac.exe命令以后，会生成一个或者多个字节码文件(.class结尾)。</p> <p>接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中，此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。</p></li> <li><p>换句话说，Class的实例就对应着一个运行时类。</p></li> <li><p>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</p></li></ol> <h2 id="_30-获取class的实例的方式"><a href="#_30-获取class的实例的方式" class="header-anchor">#</a> 30.获取Class的实例的方式</h2> <ol><li><p>调用运行时类的属性：.class</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Class</span> clazz1 <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>通过运行时类的对象，调用getClass()</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clazz2 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>调用Class的静态方法：forName(String classPath)</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Class</span> clazz3 <span class="token operator">=</span>  <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.atguigu.java.Person&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>使用类的加载器：ClassLoader</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token class-name">ReflectionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clazz4 <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">&quot;com.atguigu.java.Person&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol> <h2 id="_31-类的加载过程"><a href="#_31-类的加载过程" class="header-anchor">#</a> 31.类的加载过程</h2> <p><img src="/JavaBasisQuestions.assets/image-20220322220129245.png" alt="image-20220322220129245"></p> <p><img src="/JavaBasisQuestions.assets/image-20220322220452907.png" alt="image-20220322220452907"></p> <h2 id="_32-类加载器"><a href="#_32-类加载器" class="header-anchor">#</a> 32.类加载器</h2> <p><img src="/JavaBasisQuestions.assets/image-20220322221012346.png" alt="image-20220322221012346"></p> <p><img src="/JavaBasisQuestions.assets/image-20220322221520933.png" alt="image-20220322221520933"></p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/docs/Java/" class="prev router-link-active">
            Java专区
          </a></span> <!----></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-92abcef6><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_1-面向对象和面向过程的区别" class="sidebar-link reco-side-_1-面向对象和面向过程的区别" data-v-92abcef6>1.面向对象和面向过程的区别</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_2-java语言的特点" class="sidebar-link reco-side-_2-java语言的特点" data-v-92abcef6>2.Java语言的特点</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_3-关于jvm-jdk-和-jre最详细通俗的解答" class="sidebar-link reco-side-_3-关于jvm-jdk-和-jre最详细通俗的解答" data-v-92abcef6>3.关于JVM JDK 和 JRE最详细通俗的解答</a></li><li class="level-3" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_3-1-jvm" class="sidebar-link reco-side-_3-1-jvm" data-v-92abcef6>3.1.JVM</a></li><li class="level-3" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_3-2-jdk和jre" class="sidebar-link reco-side-_3-2-jdk和jre" data-v-92abcef6>3.2.JDK和JRE</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_4-oracle-jdk-和-openjdk-的对比" class="sidebar-link reco-side-_4-oracle-jdk-和-openjdk-的对比" data-v-92abcef6>4.Oracle JDK 和 OpenJDK 的对比</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_5-java和c-的区别" class="sidebar-link reco-side-_5-java和c-的区别" data-v-92abcef6>5.Java和C++的区别</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_6-字符型常量和字符串常量的区别" class="sidebar-link reco-side-_6-字符型常量和字符串常量的区别" data-v-92abcef6>6.字符型常量和字符串常量的区别</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_7-构造器constructor是否可被override" class="sidebar-link reco-side-_7-构造器constructor是否可被override" data-v-92abcef6>7.构造器Constructor是否可被override</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_8-重载和重写的区别" class="sidebar-link reco-side-_8-重载和重写的区别" data-v-92abcef6>8.重载和重写的区别</a></li><li class="level-3" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_8-1重载" class="sidebar-link reco-side-_8-1重载" data-v-92abcef6>8.1重载：</a></li><li class="level-3" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_8-2重写" class="sidebar-link reco-side-_8-2重写" data-v-92abcef6>8.2重写</a></li><li class="level-3" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_8-3总结" class="sidebar-link reco-side-_8-3总结" data-v-92abcef6>8.3总结</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_9-java面向对象编程三大特性-封装-继承-多态" class="sidebar-link reco-side-_9-java面向对象编程三大特性-封装-继承-多态" data-v-92abcef6>9.Java面向对象编程三大特性：封装 继承 多态</a></li><li class="level-3" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_9-1封装" class="sidebar-link reco-side-_9-1封装" data-v-92abcef6>9.1封装</a></li><li class="level-3" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_9-2继承" class="sidebar-link reco-side-_9-2继承" data-v-92abcef6>9.2继承</a></li><li class="level-3" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_9-3多态" class="sidebar-link reco-side-_9-3多态" data-v-92abcef6>9.3多态</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_10-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的" class="sidebar-link reco-side-_10-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的" data-v-92abcef6>10.String StringBuffer 和 StringBuilder 的区别是什么？ String 为什么是不可变的？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_11-自动装箱与拆箱" class="sidebar-link reco-side-_11-自动装箱与拆箱" data-v-92abcef6>11.自动装箱与拆箱</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_12-在一个静态方法内调用一个非静态成员为什么是非法的" class="sidebar-link reco-side-_12-在一个静态方法内调用一个非静态成员为什么是非法的" data-v-92abcef6>12.在一个静态方法内调用一个非静态成员为什么是非法的？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_13-在java中定义一个不做事且没有参数的构造方法的作用" class="sidebar-link reco-side-_13-在java中定义一个不做事且没有参数的构造方法的作用" data-v-92abcef6>13.在java中定义一个不做事且没有参数的构造方法的作用</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_14-接口和抽象类的区别是什么" class="sidebar-link reco-side-_14-接口和抽象类的区别是什么" data-v-92abcef6>14.接口和抽象类的区别是什么？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_15-成员变量与局部变量的区别有哪些" class="sidebar-link reco-side-_15-成员变量与局部变量的区别有哪些" data-v-92abcef6>15.成员变量与局部变量的区别有哪些？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_16-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="sidebar-link reco-side-_16-创建一个对象用什么运算符-对象实体与对象引用有何不同" data-v-92abcef6>16.创建一个对象用什么运算符？对象实体与对象引用有何不同？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_17-什么是方法的返回值-返回值在类的方法里的作用是什么" class="sidebar-link reco-side-_17-什么是方法的返回值-返回值在类的方法里的作用是什么" data-v-92abcef6>17.什么是方法的返回值？返回值在类的方法里的作用是什么？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_18-一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么" class="sidebar-link reco-side-_18-一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么" data-v-92abcef6>18.一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_19-构造方法有哪些特性" class="sidebar-link reco-side-_19-构造方法有哪些特性" data-v-92abcef6>19.构造方法有哪些特性？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_20-静态方法和实例方法有何不同" class="sidebar-link reco-side-_20-静态方法和实例方法有何不同" data-v-92abcef6>20. 静态方法和实例方法有何不同</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_21-对象的相等与指向他们的引用相等-两者有什么不同" class="sidebar-link reco-side-_21-对象的相等与指向他们的引用相等-两者有什么不同" data-v-92abcef6>21.对象的相等与指向他们的引用相等，两者有什么不同？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="sidebar-link reco-side-_22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" data-v-92abcef6>22.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_23-与-equals-重要" class="sidebar-link reco-side-_23-与-equals-重要" data-v-92abcef6>23.== 与 equals（重要）</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_24-hashcode-与-equals-重要" class="sidebar-link reco-side-_24-hashcode-与-equals-重要" data-v-92abcef6>24. hashCode 与 equals（重要）</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_25-为什么java中只有值传递" class="sidebar-link reco-side-_25-为什么java中只有值传递" data-v-92abcef6>25.为什么Java中只有值传递？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_26-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="sidebar-link reco-side-_26-简述线程、程序、进程的基本概念。以及他们之间关系是什么" data-v-92abcef6>26.简述线程、程序、进程的基本概念。以及他们之间关系是什么？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_27-线程有哪些基本状态" class="sidebar-link reco-side-_27-线程有哪些基本状态" data-v-92abcef6>27.线程有哪些基本状态？</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_28-关于-final-关键字的一些总结" class="sidebar-link reco-side-_28-关于-final-关键字的一些总结" data-v-92abcef6>28.关于 final 关键字的一些总结</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_29-关于java-lang-class类的理解" class="sidebar-link reco-side-_29-关于java-lang-class类的理解" data-v-92abcef6>29.关于java.lang.Class类的理解</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_30-获取class的实例的方式" class="sidebar-link reco-side-_30-获取class的实例的方式" data-v-92abcef6>30.获取Class的实例的方式</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_31-类的加载过程" class="sidebar-link reco-side-_31-类的加载过程" data-v-92abcef6>31.类的加载过程</a></li><li class="level-2" data-v-92abcef6><a href="/docs/Java/JavaBasisQuestions/JavaBasisQuestions.html#_32-类加载器" class="sidebar-link reco-side-_32-类加载器" data-v-92abcef6>32.类加载器</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-a008c6ba data-v-a008c6ba><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-a008c6ba><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-a008c6ba></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-a008c6ba></path></svg></div><div class="reco-bgm-panel" data-v-2940e5b8><audio id="bgm" src="/audio/RunAground.mp3" data-v-2940e5b8></audio> <div class="reco-float-box" style="bottom:200px;z-index:999999;display:none;" data-v-2940e5b8 data-v-cc4d9216 data-v-2940e5b8><img src="/img/music/RunAground.png" data-v-2940e5b8></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-2940e5b8 data-v-cc4d9216 data-v-2940e5b8><div class="reco-bgm-cover" style="background-image:url(/img/music/RunAground.png);" data-v-2940e5b8><div class="mini-operation" style="display:none;" data-v-2940e5b8><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-2940e5b8></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-2940e5b8></i></div> <div class="falut-message" style="display:none;" data-v-2940e5b8>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-2940e5b8 data-v-cc4d9216 data-v-2940e5b8><div class="info-box" data-v-2940e5b8><i class="reco-bgm reco-bgm-music music" data-v-2940e5b8></i>搁浅</div> <div class="info-box" data-v-2940e5b8><i class="reco-bgm reco-bgm-artist" data-v-2940e5b8></i>周杰伦 / 七里香</div> <div class="reco-bgm-progress" data-v-2940e5b8><div class="progress-bar" data-v-2940e5b8><div class="bar" data-v-2940e5b8></div></div></div> <div class="reco-bgm-operation" data-v-2940e5b8><i class="reco-bgm reco-bgm-last last" data-v-2940e5b8></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-2940e5b8></i> <i class="reco-bgm reco-bgm-play play" data-v-2940e5b8></i> <i class="reco-bgm reco-bgm-next next" data-v-2940e5b8></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-2940e5b8></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-2940e5b8></i> <div class="volume-bar" data-v-2940e5b8><div class="bar" data-v-2940e5b8></div></div></div></div> <div class="reco-bgm-left-box" data-v-2940e5b8 data-v-cc4d9216 data-v-2940e5b8><i class="reco-bgm reco-bgm-left" data-v-2940e5b8></i></div></div></div><!----><div class="RibbonAnimation"></div></div></div>
    <script src="/assets/js/app.810a8d16.js" defer></script><script src="/assets/js/3.442212e7.js" defer></script><script src="/assets/js/1.960485ad.js" defer></script><script src="/assets/js/13.e03968ea.js" defer></script>
  </body>
</html>
